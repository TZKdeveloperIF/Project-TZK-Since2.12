; args: [_unit, _si, _gi, bind, _idOrder, _indexCombatMode, _indexBehaviour]

_unit = _this select 0
_si = _this select 1
_gi = _this select 2

_group = (groupMatrix select _si) select _gi

? _group == (groupCommander select _si) : _this exec "Server\AI_UpdateCommander.sqs"; exit

_idOrder = _this select 4
_indexCombatMode = _this select 5
_indexBehaviour = _this select 6
_this = 0
; Refresh members' order script when each new loop started.
_order = orderMatrix select _si select _gi; _order set [0, (_order select 0) + 1]
_setting = aiSetting select _si select _gi

_unitsStarted = units _group
_funcGetSlots = preprocessFile "Server\SQF\AiGroupSlots.sqf"
_factories = []; _assignedFacs = []
_autoBuyFactories = AutoBuyStructMatrix select _si select _gi
_autoBuyTypeEntry = AutoBuyTypeMatrix select _si
_lambda = "false", _lambdaInited = false
~ 5
# Update
	? !(alive _unit): goto "WaitUntilAlive"
	
	; check if he has become CO (all players on his side has left the game)
	? _group == (groupCommander select _si) : [_unit, _si, _gi] exec "Server\AI_UpdateCommander.sqs"; exit
	
	; check if some unit has joined to other groups
	_unitsStarted = _unitsStarted - (_unitsStarted - (units _group))
	
	; check for new order
	? _idOrder == _order select 0 : goto "NoNewOrder"
	_idOrder = _order select 0
	_script = (orderDefs select (_order select 1)) select 2
	{ if (alive _x) then { [_x, _si, _gi, _order select 2] exec format["%1", _script] } } foreach _unitsStarted
	
	#NoNewOrder
	; start ai for new units
	_unitsStarted = _unitsStarted - [objNull]
	_unitsStart = (units _group) - _unitsStarted
	{ _unitsStarted set [count _unitsStarted, _x] } foreach _unitsStart
	
	; check for new CombatMode and Behaviour setting
	? _indexCombatMode == _setting select aisCombatMode: goto "SkipCombatMode"
	_indexCombatMode = _setting select aisCombatMode
	{ if !(_x call busyCheck) then {_x setCombatMode (aisCombatModeDefs select _indexCombatMode)} } foreach _unitsStarted
	#SkipCombatMode	
	? _indexBehaviour == _setting select aisBehaviour && behaviour _unit == (aisBehaviourDefs select _indexBehaviour) : goto "SkipBehaviour"
	_indexBehaviour = _setting select aisBehaviour
	_group setBehaviour (aisBehaviourDefs select _indexBehaviour)
	#SkipBehaviour

	_money = (groupMoneyMatrix select _si) select _gi
	_KeepMax = aisKeepDefs select (_setting select aisKeepMax)
	? _money > _KeepMax : _tax = _money - _KeepMax; [_si, _gi, [_si, _gi] call loadFile "Util\GetSuperiorIdx.sqf", _tax] exec localize {TZK_MONEY_SERVER_TRANSFER}; goto "Sleep"
	? _autoBuyTypeEntry select _gi != -1: goto "CheckBuyUnit"

	# Sleep
	~5
	goto "Update"

#WaitUntilAlive
	@(alive leader _group)
	_unit = leader _group
	_unit call preprocessFile "Server\SQF\RtsOrderClear.sqf"

	[_unit, _si, 200] exec localize {TZK_EVENT_ADD_KILLED_INF}
	[_unit, _si, _gi] exec "Server\EventAdd_Infantry.sqs"
	[_unit, _si, kaUnit, -1] exec localize {TZK_SERVER_KNOWSABOUT_START}
	
	_money = (groupMoneyMatrix select _si) select _gi

	? _money >= costRespawn : goto "Respawn"
#WaitMoney
	_unit setPos [-2000 + _si*100, -2000 + _gi*100, 1000]
	; _unit setPos [(posCenter select 0) + _si*100, (posCenter select 1) + _gi*100, 1000]
	_unit setVelocity [0,0,0]
	~1
	_money = (groupMoneyMatrix select _si) select _gi
	? _money < costRespawn : goto "WaitMoney"

#Respawn
	_unit call busyClear
	? costRespawn > 0 : [_si, _gi, costRespawn] exec localize {TZK_MONEY_SERVER_SPEND}
	_objectRespawn = objNull
	
	; read data from AI Setting
	? (_setting select aisRespawn) == 0 : goto "RespawnOldFashion"
	_respawnNum = (_setting select aisRespawn) % 4
	? _respawnNum == 0 : _respawnNum = 4
	_respawnType = ( (_setting select aisRespawn) - _respawnNum ) / 4
	
	_ts = structsRespawn select _respawnType	
	_workingStructures = [_si, _ts] call funcGetWorkingStructures; 
	
	if !(count _workingStructures < _respawnNum) then { _objectRespawn = _workingStructures select (_respawnNum - 1); goto "RespawnStruct" }
	
	#RespawnOldFashion
	call format["_objectRespawn = pvRespawnObjectAi%1", _si]
	? !(alive _objectRespawn) : _objectRespawn = [_objectRespawn, _si] call funcGetNearestRespawnObject

	_ts = _objectRespawn call funcGetStructTypeFromObject
	? _ts != -1 : goto "RespawnStruct"

#RespawnMHQMCV
	;_mhq = mhq select siPlayer; 	_dir = getDir _mhq; 	_pos = getPos _mhq
	_dir = getDir _objectRespawn
	_pos = getPos _objectRespawn
	_posRespawn = [(_pos select 0)-(sin _dir)*10,(_pos select 1)-(cos _dir)*10,0]
	? !(alive _objectRespawn) : _posRespawn = positionRespawn
	goto "RespawnPosSet"

#RespawnStruct
	_res = [_objectRespawn, _ts, _si] call funcCalcUnitPlacementPosDir
	_posRespawn = _res select 0
	? !(alive _objectRespawn) : _posRespawn = positionRespawn

#RespawnPosSet
	? (_posRespawn select 2) < 3: _posRespawn set [2, 3]
	_unit setVelocity [0,0,0]
	_unit setPos _posRespawn

	[_unit, _si] exec localize {TZK_AI_LEADER_EQUIP}

	unassignVehicle _unit
	
	[_unit] exec localize {TZK_REARMDATA_ADD}
	[_unit, _si, _gi] exec "Server\AI_Start.sqs"; 

	goto "Update"
	
# CheckBuyUnit
	_KeepMin = aisKeepDefs select (_setting select aisKeepMin)
	? _money <= _KeepMin: goto "Sleep"
	_slots = maxGroupSize - (count units _group + (groupUnitsBuildingMatrix select _si select _gi))
	? _slots <= 0: goto "Sleep"
	_groupSize = _setting select aisGroupSize
	? _groupSize == 1: goto "Sleep"
	? _groupSize > 1 && _groupSize < maxGroupSize: _slots = [_si, _gi, _groupSize] call _funcGetSlots; if (_slots <= 0) then {goto "Sleep"}

	_type = _autoBuyTypeEntry select _gi
	? _type == -1: goto "Sleep"

	? not ([_si, _type] call loadFile "Util\UnitCanBuy.sqf"): goto "Sleep"

	_unitDesc = unitDefs select _type
	_cost = _unitDesc select udCost
	_crew = _unitDesc select udCrew
	_driver = 0
	_gunner = 0
	? (count _crew) == 2 : _costCrew = (unitDefs select (_crew select 1)) select udCost; _driver = 1; _gunner = [0, 1] select ((_crew select 0) > 1); _cost = _cost + _driver*_costCrew + _gunner*_costCrew
	? _slots < (_driver + _gunner): goto "Sleep"
	? (_driver + _gunner) > 0 : _slots = _slots / (_driver + _gunner); _slots = _slots - _slots % 1
	? _money < _cost: goto "Sleep"
	
	_factoryType = (_unitDesc select udFactoryType) call funcBinaryDigit

	_assignedFacs resize 0
	{if (alive _x && not (_x in _assignedFacs)) then {_assignedFacs set [count _assignedFacs, _x]}} forEach _autoBuyFactories
	? count _assignedFacs > 0: goto "BuyAtSetFactory"
	; todo: To improve concurrency, optimize the concept of "idle factory / buildingsInUse" would be a good choice

	; BuyAtOldFashion
		_factories resize 0
		{[_factories, [_si, _x, true] call funcGetIdleFactories] call preprocessFile "Util\ArrayAppend.sqf"} forEach _factoryType
		? count _factories > _slots: _factories resize _slots
		{ [_type, _driver, _gunner, 0, _si, _gi, _gi, _x] exec localize {TZK_AI_BUY_UNIT} } forEach _factories
		goto "Sleep"
	
	# BuyAtSetFactory
		? not _lambdaInited: _lambdaInited = true, _lambda = format [{not ([_this, %1] call {%2})}, _si, preprocessFile "Server\SQF\LegalIdleFactory.sqf"]
		_factories resize 0
		_i = 0, _c = count _assignedFacs
		# AnalysisFac
			_factory = _assignedFacs select _i
			_facType = _factory call funcGetStructTypeFromObject
			? not (_facType in _factoryType): goto "continue_AF"
			? _factory call _lambda: goto "continue_AF"

			_factories set [count _factories, _factory]

			# continue_AF
			_i = _i + 1
			? _i < _c: goto "AnalysisFac"

		? count _factories == 0: goto "Bought"
		? count _factories > _slots : _factories resize _slots
		{ [_type, _driver, _gunner, 0, _si, _gi, _gi, _x] exec localize {TZK_AI_BUY_UNIT} } forEach _factories
	# Bought
		goto "Sleep"