; args: value

_value = _this
_value = -_value

_giTo = _value % GroupsNum
_value = (_value - _giTo) / GroupsNum

_giFrom = _value % GroupsNum
_value = (_value - _giFrom) / GroupsNum

_si = _value % 2

@!(isNull pvJoinUnits)
_unit = pvJoinUnits; pvJoinUnits = objNull
_unitsToJoin = []; { if (!isNull _x && _unitsToJoin find _x == -1) then {_unitsToJoin set [count _unitsToJoin, _x]} } forEach [driver vehicle _unit, gunner vehicle _unit, commander vehicle _unit]
_bLegalJoin = true
{ if (!(group _x in (groupAIMatrix select _si)) || _x == leader group _x) then {_bLegalJoin = false} } forEach _unitsToJoin

_members = count _unitsToJoin

_allow = 0; _full = 0; _busy = 0; _black = 0


_unitsInProgress = groupUnitsBuildingMatrix select _si select _giTo
_size = count units (groupMatrix select _si select _giTo)
? _members + _size + _unitsInProgress > maxGroupSize: _full = 1; goto "Reply"

? mutexJoinServer: _busy = 1; goto "Reply"

_blackNameIdx = TzkJoinBlackList find (name leader (groupMatrix select _si select _giTo))
? _blackNameIdx != -1: _black = 1; goto "Reply"

mutexJoinServer = true; _allow = 1; goto "Reply"


# Reply
? !_bLegalJoin: _allow = 0
_value = _allow + 2*_full + 2*2*_busy + 2*2*2*_black
pvJoinReply = _value; publicVariable "pvJoinReply"

? _busy == 1: exit
? _allow == 0: mutexJoinServer = false; exit
_leaderJoin = call format ["leaderJoin%1", _si]; _groupJoin = group _leaderJoin


	{_leaderJoin reveal _x} forEach _unitsToJoin; [_unitsToJoin, _si, _giFrom, _giTo] exec "\TZK_Scripts_4_0_5\Server\Join\DelayAssign.sqs"
	~0.1
	_unitsToJoin join _groupJoin; _unitsBck = +_unitsToJoin
	
	_try = 0; _unitsJoint = []
	#FirstRepeat
	~0.4
	_count = count _unitsToJoin; _index = 0
		#FirstGroupCheck
			? (group (_unitsToJoin select _index)) == _groupJoin: _unitsJoint = _unitsJoint + [_unitsToJoin select _index]
			_index = _index + 1
			? _index < _count: goto "FirstGroupCheck"
		_unitsToJoin = _unitsToJoin - _unitsJoint
		? count _unitsToJoin > 0 && _try < 10: _unitsToJoin join _groupJoin; _try = _try + 1; goto "FirstRepeat"
		
	~0.5
_units = (units _groupJoin) - [_leaderJoin]
if ((groupMatrix select _si select _giTo) in (groupAiMatrix select _si)) then {_units join (groupMatrix select _si select _giTo)} else { pvJoinReceive = _giTo + GroupsNum*_si; publicVariable "pvJoinReceive" }
? (groupMatrix select _si select _giFrom) in (groupAiMatrix select _si): _order = orderMatrix select _si select _giFrom; _order set [0, (_order select 0) + 3]


? !((groupMatrix select _si select _giTo) in (groupAiMatrix select _si)): goto "DONE"
? count _units == 0: goto "DONE"
	_try = 0; _unitsJoint = []
	#SecondRepeat
	~0.4
	_count = count _units; _index = 0
		#SecondGroupCheck
			? (group (_units select _index)) == (groupMatrix select _si select _giTo): _unitsJoint = _unitsJoint + [_units select _index]
			_index = _index + 1
			? _index < _count: goto "SecondGroupCheck"
		_units = _units - _unitsJoint
		? count _units > 0 && _try < 10: _units join (groupMatrix select _si select _giTo); _try = _try + 1; goto "SecondRepeat"


#DONE
{doStop _x} forEach _unitsBck
; Wait till Join Process completed
_timeAbort = time + 15
@( count (units _groupJoin) == 1 || time > _timeAbort )

; Join might fail on client sometimes, especially when someone lags.
? count (units _groupJoin) == 1: goto "QUIT"

_units = (units _groupJoin) - [_leaderJoin]; {_x setPos getPos _x} forEach _units
~2
{deleteVehicle _x} forEach _units

#QUIT

~1
mutexJoinServer = false

; EOF